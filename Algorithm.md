* ### **背调**

1. 跟领导关系是否融洽

2. 工作中有没有负面情绪

3. 与团队关系怎么样

4. 业务技能 （中上等 ）

5. 抗压能力

6. 是否能按时完成工作任务

   

* ### **文件中有40亿个QQ号码，设计算法对QQ号码去重，相同的QQ号码仅保留一个，内存限制1G**

>1. hash map 自然去重，内存限制无法满足  (not ok)
>2. 排序 [解为多个文件然后用 合并排序或者桶排序]，排序后可以方便的去重。(not ok)
>3. bitmap QQ号码为非负正整数且有最大值(类似桶排序)，处理好后可直接作 去重 。
>4. 如果QQ号码均不相同 则可以作 top-K 排序使用。

* ### **在2.5亿个整数中找出不重复的整数，注，内存不足以容纳这2.5亿个整数**

>1. 采用2-Bitmap（每个数分配2bit，00表示不存在，01表示出现一次，10表示多次，11无意义）进行，共需内存$2^{32}\times2=1G$内存，还可以接受。然后扫描这2.5亿个整数，查看Bitmap中相对应位，如果是00变01，01变10，10保持不变。所描完事后，查看bitmap，把对应位是01的整数输出即可。
>2. 进行划分小文件的方法。然后在小文件中找出不重复的整数，并排序。然后再进行归并，注意去除重复的元素.

* ### **负数 --》取模 取余 的区别**

1. 取模 商趋向于 负无穷
2. 取余 商趋向于 正无穷



* ### **计算递归算法时间复杂度的方法，是找到递归深度，然后乘以每次递归中迭代的次数**



* ### **无序数组中找到$Kth$大(小)的值**

>1. 排序后找到$Kth$值 Time: $O(Nlog_2N)$
>2. 遍历数据同时放入堆 Time:$O(Nlog_2K)$
>3. [**快速选择**]  类似  [**快速排序**] 能以**最快$O(2N-1)$**,\[**最差$O(N^2)$有序数组**\]速度找打$Kth$值 (e.g.  215)






* ### 死锁及检测死锁
>1. 在MySQL中，当两个或两个以上的事务相互持有或者请求锁，并形成一个**循环的依赖关系**，就会产生死锁
>2. 两个或两个以上任务同时拥有并请求彼此的资源，请求时**形成一个循环依赖关系**，会产生死锁
>> 1. MySQL 的死锁检测算法是**深度优先搜索，如果在搜索过程中发现了环，就说明发生了死锁**. 为了避免死锁检测开销过大，如果搜索深度超过了 200（LOCK_MAX_DEPTH_IN_DEADLOCK_CHECK)也同样认为发生了死锁。[e.g. [here](https://leviathan.vip/2020/02/02/mysql-deadlock-check/)]
>> 2. InnoDB 使用 MVCC 来解决事务的并发控制，而其中 Undo Log 是 MVCC 的重要组成部分